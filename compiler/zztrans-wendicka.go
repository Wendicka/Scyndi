package scynt


//import "fmt"
import "strconv"

func init(){
	
	
	
	
	TransMod["Wendicka"] = &T_TransMod {}
	tmw:=TransMod["Wendicka"]
	tmw.extension="wsf"
	tmw.endlessargs=true
	
	/*
	tmw.NameIdentifiers = func(src *tsource) {
		//for _,src := range p.sources {
			for _,id := range src.identifiers {
				fmt.Println("HUH?\t",id.tarformed,id.idtype,id.translateto)
				if !id.tarformed {
					pchat("Transforming "+id.idtype+" "+id.translateto)
					if id.idtype=="VAR" { id.translateto = "$"+id.translateto }
					id.tarformed=true
				}
			}
		//}
	}
	*/
	
	tmw.TransVars = func(src *tsource) string{

		ret:="\tCHUNK SYSCYNDI_VAR\n"
		for vname,vdata:=range src.identifiers {
			if vdata.idtype=="VAR" {
				if src.orilinerem { ret += "\t\t# VAR "+vname+"\n"}
				vdata.translateto = "$"+vdata.translateto
				ret += "\t\tMOV "+vdata.translateto+","
				if vdata.defstring { ret += "\""+vdata.defaultvalue+"\"\n" } else { ret+=vdata.defaultvalue+"\n" }
			}
		}
		
		return ret
	}
	
	tmw.FuncHeaderRem = func() string { return "# Functions translated into chunks\n\n" }
	
	tmw.FuncHeader = func(s *tsource,ch *tchunk) string {
		ret := "\tCHUNK "+ch.translateto+"\n"
		for i,a:=range ch.args.a {
			v:=a.arg
			v.translateto = "$"+v.translateto			
			ret += "\t\tGETARG "+v.translateto+","+strconv.Itoa(i)+"\n"
		}
		return ret
	}
	
	tmw.EndFunc = func(s *tsource,ch *tchunk,trueend bool) string {
		//ret := "\t\t# Returning values\n"
		ret := "\t\t# Cleaning up locals\n"
		for _,v:=range ch.locals {
			ret += "\t\tDISPOSE "+v.translateto+"\n"
		}
		if !trueend { ret+="\t" }
		ret += "\tEXIT"
		return ret
	}
	
	/* temp out of use
	tmw.plusone  = func(i *tidentifier) string { return "\tINC "+i.translateto+",1"}
	tmw.minusone = func(i *tidentifier) string { return "\tDEC "+i.translateto+",1"}
	*/
	
	
	tmw.Merge = func(b map[string]string) string {
		ret:="# Code generated by Scyndi\n\n"
		ret+=b["VAR"]+"\n\n"
		ret+=b["FUN"]+"\n\n"
		ret+="\n\n\tCHUNK __LOAD\n\t\tCALL SYSCYNDI_VAR\n"
		return ret
	}
	
	
}

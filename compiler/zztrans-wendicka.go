/*
	Scyndi
	Translate to Wendicka
	
	
	
	(c) Jeroen P. Broks, 2018, All rights reserved
	
		This program is free software: you can redistribute it and/or modify
		it under the terms of the GNU General Public License as published by
		the Free Software Foundation, either version 3 of the License, or
		(at your option) any later version.
		
		This program is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		GNU General Public License for more details.
		You should have received a copy of the GNU General Public License
		along with this program.  If not, see <http://www.gnu.org/licenses/>.
		
	Exceptions to the standard GNU license are available with Jeroen's written permission given prior 
	to the project the exceptions are needed for.
Version: 18.07.21
*/
package scynt


//import "fmt"
import "strconv"

func init(){
	
	
	
	
	TransMod["Wendicka"] = &T_TransMod {}
	tmw:=TransMod["Wendicka"]
	tmw.extension="wsf"
	tmw.endlessargs=true
	
	/*
	tmw.NameIdentifiers = func(src *tsource) {
		//for _,src := range p.sources {
			for _,id := range src.identifiers {
				fmt.Println("HUH?\t",id.tarformed,id.idtype,id.translateto)
				if !id.tarformed {
					pchat("Transforming "+id.idtype+" "+id.translateto)
					if id.idtype=="VAR" { id.translateto = "$"+id.translateto }
					id.tarformed=true
				}
			}
		//}
	}
	*/
	
	tmw.TransVars = func(src *tsource) string{

		ret:="\tCHUNK SYSCYNDI_VAR\n"
		for vname,vdata:=range src.identifiers {
			if vdata.idtype=="VAR" {
				if src.orilinerem { ret += "\t\t# VAR "+vname+"\n"}
				vdata.translateto = "$"+vdata.translateto
				ret += "\t\tMOV "+vdata.translateto+","
				if vdata.defstring { ret += "\""+vdata.defaultvalue+"\"\n" } else { ret+=vdata.defaultvalue+"\n" }
			}
		}
		
		return ret
	}
	
	tmw.FuncHeaderRem = func() string { return "# Functions translated into chunks\n\n" }
	
	tmw.FuncHeader = func(s *tsource,ch *tchunk) string {
		ret := "\tCHUNK "+ch.translateto+"\n"
		for i,a:=range ch.args.a {
			v:=a.arg
			v.translateto = "$"+v.translateto			
			ret += "\t\tGETARG "+v.translateto+","+strconv.Itoa(i)+"\n"
		}
		return ret
	}
	
	tmw.EndFunc = func(s *tsource,ch *tchunk,trueend bool) string {
		//ret := "\t\t# Returning values\n"
		ret := "\t\t# Cleaning up locals\n"
		for _,v:=range ch.locals {
			ret += "\t\tDISPOSE "+v.translateto+"\n"
		}
		if !trueend { ret+="\t" }
		ret += "\tEXIT"
		return ret
	}
	
	/* temp out of use
	tmw.plusone  = func(i *tidentifier) string { return "\tINC "+i.translateto+",1"}
	tmw.minusone = func(i *tidentifier) string { return "\tDEC "+i.translateto+",1"}
	*/
	
	
	tmw.Merge = func(b map[string]string) string {
		ret:="# Code generated by Scyndi\n\n"
		ret+=b["VAR"]+"\n\n"
		ret+=b["FUN"]+"\n\n"
		ret+="\n\n\tCHUNK __LOAD\n\t\tCALL SYSCYNDI_VAR\n"
		return ret
	}
	
	
}
